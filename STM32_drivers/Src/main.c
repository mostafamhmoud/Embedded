/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "../MCAL/RCC/inc/RCC_interface.h"
#include "../MCAL/GPIO/inc/GPIO_interface.h"
#include "../MCAL/NVIC/inc/NVIC_interface.h"
#include "../MCAL/EXTI/inc/EXTI_interface.h"
#include "../MCAL/SYSCFG/inc/SYSCFG_interface.h"
#include "../MCAL/USART/inc/UART_interface.h"
#include "../MCAL/dma/inc/DMA_interface.h"
#include "../MCAL/I2C/inc/I2C_interface.h"
#include "../HAL/RTC/inc/RTC_DS1307_interface.h"

/*
int main(void)
{

	NVIC_EnableIRQ(DMA1_Stream0_IRQn);

	ST_RCC_Config_t rcc_user_specs =
	{
		.Sys_Clk_Select = HSI_system_clock_select,
		.PLL_clk_src = HSI,
		.PLLM_Pres = 50 ,
		.PLLN_Factor = 200 ,
		.PLLP_Pres = PLLP_devided_by_2,
		.AHP_Pres = AHB_SYSCLK_devided_by_4,
		.APB1_Pres = APB1_HCLK_not_divided,
		.APB2_Pres = APB2_HCLK_not_divided
	};

	RCC_Config(&rcc_user_specs);

	RCC_Enable_Peripheral(GPIOAEN);

	ST_Pin_Config led_pin =
	{
			.Port_X = PORTA ,
			.mode = OUTPUT ,
			.Pin_Num = PIN5 ,
			.speed = LOW ,
			.Output_Type = PUSH_PULL ,
			.PullType = NO_PULL
	};

	GPIO_u8PIN_init(&led_pin);
	GPIO_u8Set_Pin_Value(PORTA , PIN5 , PIN_HIGH) ;

	for(;;);
}

void DMA1_Stream0_IRQHandler(void)
{
	int x = 50;
}

*/


/*
void EXTI0_func(void);
int main()
{
	ST_RCC_Config_t rcc_user_specs =
	{
		.Sys_Clk_Select = HSI_system_clock_select,
		.PLL_clk_src = HSI,
		.PLLM_Pres = 50 ,
		.PLLN_Factor = 200 ,
		.PLLP_Pres = PLLP_devided_by_2,
		.AHP_Pres = AHB_SYSCLK_devided_by_4,
		.APB1_Pres = APB1_HCLK_not_divided,
		.APB2_Pres = APB2_HCLK_not_divided
	};

	RCC_Config(&rcc_user_specs);

	RCC_Enable_Peripheral(GPIOCEN);
	RCC_Enable_Peripheral(GPIOAEN);


	ST_Pin_Config butt_pin =
	{
			.Port_X = PORTC ,
			.mode = INPUT ,
			.Pin_Num = PIN13 ,
			.speed = LOW ,
			.PullType = PULL_UP
	};

	ST_Pin_Config led_pin =
	{
			.Port_X = PORTA ,
			.mode = OUTPUT ,
			.Pin_Num = PIN5 ,
			.Output_Type = PUSH_PULL,
			.speed = LOW ,
			.PullType = NO_PULL
	};

	GPIO_u8PIN_init(&butt_pin);
	GPIO_u8PIN_init(&led_pin);

	ST_EXTI_Config_t pin_int =
	{
		.line_num = EXTI_LINE0,
		.edge_detect = FALLING_TRIG,
		.init_state = ENABLE,
		.CallBackFun = EXTI0_func,
	};

	EXTI_init(&pin_int);

	SYSCFG_Set_Line(PC, LINE0);


}


void EXTI0_func(void)
{
	GPIO_u8Set_Pin_Value(PORTA, PIN5, PIN_HIGH);
}
*/

/* USART DMA try */

/*
void usart_GPIO_init(void)
{
	ST_Pin_Config butt1_pin =
	{
			.Port_X = PORTA ,
			.mode = ALTERNATE_FUNCTION ,
			.Alt_Func = AF7,
			.Pin_Num = PIN2 ,
			.speed = HIGH ,
			.PullType = NO_PULL,
	};

	ST_Pin_Config butt2_pin =
	{
			.Port_X = PORTA ,
			.mode = ALTERNATE_FUNCTION ,
			.Alt_Func = AF7,
			.Pin_Num = PIN3 ,
			.speed = HIGH ,
			.PullType = NO_PULL,
	};

	GPIO_u8PIN_init(&butt1_pin);
	GPIO_u8PIN_init(&butt2_pin);

}

int x = 50;
void call_func(void)
{
	x = 70;
}

uint8_t source[20] = { 0 };

int main()
{
	ST_RCC_Config_t rcc_user_specs =
	{
		.Sys_Clk_Select = HSI_system_clock_select,
		.PLL_clk_src = HSI,
		.PLLM_Pres = 50 ,
		.PLLN_Factor = 200 ,
		.PLLP_Pres = PLLP_devided_by_2,
		.AHP_Pres = AHB_SYSCLK_not_devided,
		.APB1_Pres = APB1_HCLK_not_divided,
		.APB2_Pres = APB2_HCLK_not_divided
	};

	RCC_Config(&rcc_user_specs);

	RCC_Enable_Peripheral(USART2EN);
	RCC_Enable_Peripheral(GPIOAEN);
	RCC_Enable_Peripheral(DMA1EN);
	usart_GPIO_init();

	ST_USART_Config_t usart_config =
	{
		.baud_rate = 115200 ,
		.clk_phase = FIRST_CLK_TRANS,
		.clk_pol = STD_LOW,
		.data_length = DATA_BITS_8,
		.half_duplex_select = HALF_DUPLEX_NOT_SELECTED,
		.mode = TRANSMITTER_RECEIVER,
		.ov_s_mode = OVERSAMPLING_BY_16,
		.parity_en_dis = PARITY_CONTROL_DISABLE,
		.parity_ev_odd = EVEN_PARITY,
		.stop_bits = ONE_STOP_BIT,
		.sync_async = ASYNCHRONOUS,
		.usart_num = USART_NUM_2,
		.dma_stream_used = STREAM6_USED_USART,
		.dma_used = DMA1_USED_USART,
	};

	USART_init(&usart_config);

	ST_DMA_config_t dma_config =
	{
		// initialize callback functions for different interrupt sources
		.DMA_CallBackFun[Transfer_Complete_ID] = call_func,
		.DMA_CallBackFun[Transfer_Error_ID] = call_func ,
		.DMA_CallBackFun[Half_Transfer_ID] = call_func ,
		.DMA_CallBackFun[FIFO_Error_ID] = call_func ,
		.DMA_CallBackFun[Direct_Mode_Error_ID] = call_func ,

		.DMA_str_num = STREAM6 ,
		.DMA_ch_num = CHANNEL4 ,
		.DMA_Circular_mode = CIRCULAR_MODE_DISABLE,
		.DMA_controller = DMA1 ,
		.DMA_dir = M2P ,
		.DMA_fifo_select = QUARTER_FULL_FIFO ,
		// select interrupts , just enable Transfer_Complete_IT
		.DMA_IT_State.Direct_Mode_Error_IT = DMA_IT_DISABLE,
		.DMA_IT_State.FIFO_Error_IT = DMA_IT_DISABLE,
		.DMA_IT_State.Half_Transfer_IT = DMA_IT_DISABLE,
		.DMA_IT_State.Transfer_Complete_IT = DMA_IT_ENABLE ,
		.DMA_IT_State.Transfer_Error_IT = DMA_IT_DISABLE,
		.DMA_mem_inc = MINC_ENABLE,
		.DMA_p_inc = PINC_DISABLE,
		.DMA_mode = DIRECT_MODE,
		.DMA_p_allign = BYTE ,
		.DMA_mem_allign = BYTE,
		.DMA_str_priority = HIGH_PRIORITY ,
	};

	DMA_Init(&dma_config);

	DMA_Set_Callback(&dma_config, Transfer_Complete_ID);

	NVIC_EnableIRQ(DMA1_Stream6_IRQn);

	for (uint8_t i = 0; i < 20; i++)
	{
		source[i] = i;
	}

	USART_Transmit_DMA(&usart_config, (uint32_t)source, 20);
	while (1)
	{
		//USART_Transmit_DMA(&usart_config, (uint32_t)source, 20);
	}
}
*/




/* RTC try */


ST_RTC_DS1307_Date_t cur_date =
{
	.seconds = 0,
	.min = 15,
	.hours = 21,
	.day = 7,
	.date = 6,
	.month = 10 ,
	.year = 23 ,
};

ST_RTC_DS1307_Date_t next_time =
{
	.seconds = 0,
	.min = 0,
	.hours = 0,
	.day = 0,
	.date = 0,
	.month = 0 ,
	.year = 0 ,
};

void I2C_GPIO_init(void)
{
	ST_Pin_Config butt1_pin =
	{
			.Port_X = PORTB ,
			.mode = ALTERNATE_FUNCTION ,
			.Alt_Func = AF4,
			.Pin_Num = PIN8 ,
			.speed = HIGH ,
			.Output_Type = OPEN_DRAIN,
			.PullType = PULL_UP ,
	};

	ST_Pin_Config butt2_pin =
	{
			.Port_X = PORTB ,
			.mode = ALTERNATE_FUNCTION ,
			.Alt_Func = AF4,
			.Pin_Num = PIN9 ,
			.speed = HIGH ,
			.Output_Type = OPEN_DRAIN,
			.PullType = PULL_UP,
	};

	GPIO_u8PIN_init(&butt1_pin);
	GPIO_u8PIN_init(&butt2_pin);

}


int i2x = 20;
void call_func(void)
{
	i2x = 60;
}

uint8_t src[20] = { 0 };

uint8_t dest[20] = { 0 };

int main()
{
	ST_RCC_Config_t rcc_user_specs =
	{
		.Sys_Clk_Select = HSI_system_clock_select,
		.PLL_clk_src = HSI,
		.PLLM_Pres = 50 ,
		.PLLN_Factor = 200 ,
		.PLLP_Pres = PLLP_devided_by_2,
		.AHP_Pres = AHB_SYSCLK_not_devided,
		.APB1_Pres = APB1_HCLK_not_divided,
		.APB2_Pres = APB2_HCLK_not_divided
	};

	RCC_Config(&rcc_user_specs);

	RCC_Enable_Peripheral(GPIOBEN);

	RCC_Enable_Peripheral(I2C1EN);

	I2C_GPIO_init();

	ST_I2C_Config_t i2c1_config =
	{
		.i2c_num = I2C_NUM_1 ,
		.addr_mode = SLAVE_ADDRESS_7_BIT,
		.CLK_stretch = CLOCK_STRETCHING_DISABLED,
		.dma_stream_used_Tx = STREAM6,
		.dma_stream_used_Rx = STREAM5,
		.dma_used = DMA1_USED,
		.dual_add_mode = DUAL_ADDRESSING_MODE_DISABLE ,
		.duty = FM_MODE_DUTY_2,
		.gen_call = GENERAL_CALL_DISABLED,
		.last_transfer = NEXT_DMA_EOT_IS_NOT_THE_LAST_TRANSFER,
		.master_mode = SM_MODE,
		.PCLK_freq_in_mhz = 16 ,
		.PEC_en_dis = PEC_CALCULATION_DISABLED,
		.SCL_freq_in_khz = 100,
		.smbus_mode = I2C_MODE,
		.smbus_type = SMBUS_DEVICE,
	};

	I2C_init(&i2c1_config);

	RCC_Enable_Peripheral(DMA1EN);


	ST_DMA_config_t dma_config_Rx =
	{
		// initialize callback functions for different interrupt sources
		.DMA_CallBackFun[Transfer_Complete_ID] = call_func,
		.DMA_CallBackFun[Transfer_Error_ID] = call_func ,
		.DMA_CallBackFun[Half_Transfer_ID] = call_func ,
		.DMA_CallBackFun[FIFO_Error_ID] = call_func ,
		.DMA_CallBackFun[Direct_Mode_Error_ID] = call_func ,

		.DMA_str_num = STREAM5 ,
		.DMA_ch_num = CHANNEL1 ,
		.DMA_Circular_mode = CIRCULAR_MODE_DISABLE,
		.DMA_controller = DMA1 ,
		.DMA_dir = P2M ,
		.DMA_fifo_select = QUARTER_FULL_FIFO ,
		// select interrupts , just enable Transfer_Complete_IT
		.DMA_IT_State.Direct_Mode_Error_IT = DMA_IT_DISABLE,
		.DMA_IT_State.FIFO_Error_IT = DMA_IT_DISABLE,
		.DMA_IT_State.Half_Transfer_IT = DMA_IT_DISABLE,
		.DMA_IT_State.Transfer_Complete_IT = DMA_IT_ENABLE ,
		.DMA_IT_State.Transfer_Error_IT = DMA_IT_DISABLE,
		.DMA_mem_inc = MINC_ENABLE,
		.DMA_p_inc = PINC_DISABLE,
		.DMA_mode = DIRECT_MODE,
		.DMA_p_allign = BYTE ,
		.DMA_mem_allign = BYTE,
		.DMA_str_priority = HIGH_PRIORITY ,
	};

	DMA_Init(&dma_config_Rx);

	ST_DMA_config_t dma_config_Tx =
	{
		// initialize callback functions for different interrupt sources
		.DMA_CallBackFun[Transfer_Complete_ID] = call_func,
		.DMA_CallBackFun[Transfer_Error_ID] = call_func ,
		.DMA_CallBackFun[Half_Transfer_ID] = call_func ,
		.DMA_CallBackFun[FIFO_Error_ID] = call_func ,
		.DMA_CallBackFun[Direct_Mode_Error_ID] = call_func ,

		.DMA_str_num = STREAM6 ,
		.DMA_ch_num = CHANNEL1 ,
		.DMA_Circular_mode = CIRCULAR_MODE_DISABLE,
		.DMA_controller = DMA1 ,
		.DMA_dir = M2P ,
		.DMA_fifo_select = QUARTER_FULL_FIFO ,
		// select interrupts , just enable Transfer_Complete_IT
		.DMA_IT_State.Direct_Mode_Error_IT = DMA_IT_DISABLE,
		.DMA_IT_State.FIFO_Error_IT = DMA_IT_DISABLE,
		.DMA_IT_State.Half_Transfer_IT = DMA_IT_DISABLE,
		.DMA_IT_State.Transfer_Complete_IT = DMA_IT_ENABLE ,
		.DMA_IT_State.Transfer_Error_IT = DMA_IT_DISABLE,
		.DMA_mem_inc = MINC_ENABLE,
		.DMA_p_inc = PINC_DISABLE,
		.DMA_mode = DIRECT_MODE,
		.DMA_p_allign = BYTE ,
		.DMA_mem_allign = BYTE,
		.DMA_str_priority = HIGH_PRIORITY ,
	};

	DMA_Init(&dma_config_Tx);

	DMA_Set_Callback(&dma_config_Rx, Transfer_Complete_ID);
	DMA_Set_Callback(&dma_config_Tx, Transfer_Complete_ID);

	NVIC_EnableIRQ(DMA1_Stream5_IRQn);
	NVIC_EnableIRQ(DMA1_Stream6_IRQn);

	uint8_t slave_add = 0x68;

	for (uint8_t i = 0; i < 20; i++)
	{
		src[i] = i;
	}

	RTC_DS1307_Set_Date(&i2c1_config, &cur_date);
	while (1)
	{

	}

}
